#![allow(unused_variables)] // TODO: remove this

use crate::error::*;
use sntk_bytecode::interpreter::*;
use sntk_core::parser::ast::*;

/// Compile the AST generated by `sntk_core` parser into bytecode.
#[derive(Debug)]
pub struct Compiler {
    pub program: Program,
    pub interpreter: Interpreter,
}

pub type CompileResult<T> = Result<T, CompileError>;

/// Provides the basic methods of the compiler.
pub trait CompilerTrait {
    fn compile_program(&self) -> CompileResult<Interpreter>;
    fn compile_let_statement(&self, let_statement: &LetStatement) -> CompileResult<CompileError>;
    fn compile_return_statement(&self, return_statement: &ReturnStatement) -> CompileResult<CompileError>;
    fn compile_type_statement(&self, type_statement: &TypeStatement) -> CompileResult<CompileError>;
    fn compile_expression_statement(&self, expression: &ExpressionStatement) -> CompileResult<CompileError>;
}

impl CompilerTrait for Compiler {
    /// Compile the AST generated by `sntk_core` parser into bytecode.
    fn compile_program(&self) -> CompileResult<Interpreter> {
        if self.program.errors.len() > 0 {
            return Err(CompileError::ParseError(self.program.errors.clone()));
        }

        for statement in &self.program.statements {
            match statement {
                Statement::LetStatement(statement) => self.compile_let_statement(statement)?,
                Statement::ReturnStatement(statement) => self.compile_return_statement(statement)?,
                Statement::TypeStatement(statement) => self.compile_type_statement(statement)?,
                Statement::ExpressionStatement(expression) => self.compile_expression_statement(expression)?,
            };
        }

        Ok(self.interpreter.clone())
    }

    /// Compile a `let` statement.
    fn compile_let_statement(&self, let_statement: &LetStatement) -> CompileResult<CompileError> {
        todo!()
    }

    /// Compile a `return` statement.
    fn compile_return_statement(&self, return_statement: &ReturnStatement) -> CompileResult<CompileError> {
        todo!()
    }

    /// Compile a `type` statement.
    fn compile_type_statement(&self, type_statement: &TypeStatement) -> CompileResult<CompileError> {
        todo!()
    }

    /// Compile an expression statement.
    fn compile_expression_statement(&self, expression: &ExpressionStatement) -> CompileResult<CompileError> {
        todo!()
    }
}
