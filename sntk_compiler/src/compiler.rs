use crate::error::*;
use sntk_bytecode::{builtin::*, code::*, interpreter::*, stack::*};
use sntk_core::{parser::ast::*, tokenizer::token::Tokens};

#[derive(Debug, Clone)]
pub struct Code(pub Vec<Instruction>);

impl Code {
    fn new() -> Self {
        Self(Vec::new())
    }

    fn push_instruction(&mut self, instruction: Instruction) {
        self.0.push(instruction);
    }
}

/// Compile the AST generated by `sntk_core` parser into bytecode.
#[derive(Debug)]
pub struct Compiler {
    pub program: Program,
    pub code: Code,
}

pub type CompileResult<T> = Result<T, CompileError>;

/// Provides the basic methods of the compiler.
pub trait CompilerTrait {
    fn new(program: Program) -> Self;
    fn compile_program(&mut self) -> CompileResult<Interpreter>;
    fn compile_let_statement(&mut self, let_statement: LetStatement) -> CompileResult<()>;
    fn compile_return_statement(&mut self, return_statement: ReturnStatement) -> CompileResult<()>;
    fn compile_type_statement(&mut self, type_statement: TypeStatement) -> CompileResult<()>;
    fn compile_expression(&mut self, expression: Expression) -> CompileResult<()>;
}

impl CompilerTrait for Compiler {
    /// **Creates a new Compiler instance.**
    /// it takes an argument of type `Program`.
    fn new(program: Program) -> Self {
        Self { program, code: Code::new() }
    }

    /// Compile the AST generated by `sntk_core` parser into bytecode.
    fn compile_program(&mut self) -> CompileResult<Interpreter> {
        if self.program.errors.len() > 0 {
            return Err(CompileError::ParseError(self.program.errors.clone()));
        }

        for statement in self.program.statements.clone() {
            match statement {
                Statement::LetStatement(statement) => self.compile_let_statement(statement)?,
                Statement::ReturnStatement(statement) => self.compile_return_statement(statement)?,
                Statement::TypeStatement(statement) => self.compile_type_statement(statement)?,
                Statement::ExpressionStatement(ExpressionStatement { expression, .. }) => self.compile_expression(expression)?,
            };
        }

        Ok(Interpreter::new(self.code.clone().0))
    }

    /// Compile a `let` statement.
    ///
    /// `let x: number = 5;` to bytecode:
    /// ```
    /// Instruction:
    ///     0: LoadConst 5.0
    ///     1: StoreName "x"
    /// ```
    fn compile_let_statement(&mut self, let_statement: LetStatement) -> CompileResult<()> {
        let LetStatement { name, value, data_type, .. } = let_statement;

        self.compile_expression(value)?;
        self.code.push_instruction(Instruction::StoreName(name.value));

        Ok(())
    }

    /// Compile a `return` statement.
    fn compile_return_statement(&mut self, return_statement: ReturnStatement) -> CompileResult<()> {
        todo!()
    }

    /// Compile a `type` statement.
    fn compile_type_statement(&mut self, type_statement: TypeStatement) -> CompileResult<()> {
        todo!()
    }

    /// Compile an expression statement.
    fn compile_expression(&mut self, expression: Expression) -> CompileResult<()> {
        match expression {
            Expression::NumberLiteral(NumberLiteral { value, .. }) => {
                self.code
                    .push_instruction(Instruction::LoadConst(Value::LiteralValue(LiteralValue::Number(value))));
                self.code
                    .push_instruction(Instruction::LoadConst(Value::LiteralValue(LiteralValue::Number(value))));
                Ok(())
            }

            Expression::Identifier(Identifier { value, .. }) => {
                self.code.push_instruction(Instruction::LoadName(value));
                Ok(())
            }

            // TODO
            // function(1, 2, 3);
            //
            // Instruction:
            //   0: LoadConst 0
            //   1: LoadConst 1
            //   2: LoadConst 2
            //   3: LoadConst 3
            //   4: Call 3
            // Constant:
            //   0: 1
            //   1: 2
            //   2: 3
            //   3: function
            Expression::CallExpression(CallExpression { function, arguments, .. }) => {
                for argument in arguments.clone() {
                    self.compile_expression(argument)?;
                }

                match *function.clone() {
                    Expression::Identifier(Identifier { value, .. }) => match get_builtin(value.clone()) {
                        Some(_) => self.code.push_instruction(Instruction::LoadGlobal(value.clone())),
                        None => self.code.push_instruction(Instruction::LoadName(value.clone())),
                    },
                    _ => todo!(),
                }

                self.code.push_instruction(Instruction::CallFunction(arguments.len()));
                Ok(())
            }

            Expression::InfixExpression(InfixExpression { left, operator, right, .. }) => {
                self.compile_expression(*left)?;
                self.compile_expression(*right)?;

                match operator {
                    Tokens::Plus => self.code.push_instruction(Instruction::BinaryOp(BinaryOp::Add)),
                    _ => unimplemented!(),
                }

                Ok(())
            }

            e => {
                println!("err: {:?}", e);
                unimplemented!()
            }
        }
    }
}
