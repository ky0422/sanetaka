use crate::error::CompileError;
use sntk_core::{
    parser::ast::{
        ArrayLiteral, BlockExpression, BooleanLiteral, CallExpression, Expression, ExpressionStatement, FunctionLiteral, Identifier, IfExpression,
        IndexExpression, InfixExpression, LetStatement, NumberLiteral, ObjectLiteral, PrefixExpression, Program, ReturnStatement, Statement,
        StringLiteral, TypeStatement,
    },
    tokenizer::token::Tokens,
};
use sntk_ir::{
    builtin::get_builtin,
    code::{BinaryOp, BinaryOpEq, Block, Instruction, UnaryOp},
    interpreter::{Interpreter, InterpreterBase},
    stack::{LiteralValue, Value},
};

#[derive(Debug, Clone)]
pub struct Code(pub Vec<Instruction>);

impl Code {
    fn new() -> Self {
        Self(Vec::new())
    }

    fn push_instruction(&mut self, instruction: &Instruction) {
        self.0.push(instruction.clone());
    }
}

/// Compile the AST generated by `sntk_core` parser into Sanetaka IR.
#[derive(Debug)]
pub struct Compiler {
    pub program: Program,
    pub code: Code,
}

pub type CompileResult<T> = Result<T, CompileError>;

/// Provides the basic methods of the compiler.
pub trait CompilerTrait {
    fn new(program: Program) -> Self;
    fn compile_program(&mut self) -> CompileResult<Interpreter>;
    fn compile_let_statement(&mut self, let_statement: &LetStatement) -> CompileResult<()>;
    fn compile_return_statement(&mut self, return_statement: &ReturnStatement) -> CompileResult<()>;
    fn compile_type_statement(&mut self, type_statement: &TypeStatement) -> CompileResult<()>;
    fn compile_expression(&mut self, expression: &Expression) -> CompileResult<()>;
}

impl CompilerTrait for Compiler {
    /// **Creates a new Compiler instance.**
    /// it takes an argument of type `Program`.
    fn new(program: Program) -> Self {
        Self { program, code: Code::new() }
    }

    /// Compile the AST generated by `sntk_core` parser into Sanetaka IR.
    fn compile_program(&mut self) -> CompileResult<Interpreter> {
        if !self.program.errors.is_empty() {
            return Err(CompileError::ParseError(self.program.errors.clone()));
        }

        for statement in self.program.statements.clone() {
            match statement {
                Statement::LetStatement(statement) => self.compile_let_statement(&statement)?,
                Statement::ReturnStatement(statement) => self.compile_return_statement(&statement)?,
                Statement::TypeStatement(statement) => self.compile_type_statement(&statement)?,
                Statement::ExpressionStatement(ExpressionStatement { expression, .. }) => self.compile_expression(&expression)?,
            };
        }

        Ok(Interpreter::new(self.code.clone().0))
    }

    /// Compile a `let` statement.
    ///
    /// `let x: number = 5;` to Sanetaka IR:
    /// ```
    /// Instruction:
    ///     0: LoadConst 5.0
    ///     1: StoreName "x"
    /// ```
    fn compile_let_statement(&mut self, let_statement: &LetStatement) -> CompileResult<()> {
        let LetStatement {
            name,
            value, /* data_type, */
            ..
        } = let_statement;

        self.compile_expression(value)?;
        self.code.push_instruction(&Instruction::StoreName(name.clone().value));

        Ok(())
    }

    /// Compile a `return` statement.
    ///
    /// `return 5;` to Sanetaka IR:
    /// ```
    /// Instruction:
    ///     0: LoadConst 5.0
    ///     1: Return
    /// ```
    fn compile_return_statement(&mut self, return_statement: &ReturnStatement) -> CompileResult<()> {
        let ReturnStatement { value, .. } = return_statement;

        self.compile_expression(value)?;
        self.code.push_instruction(&Instruction::Return);

        Ok(())
    }

    /// Compile a `type` statement.
    #[allow(unused_variables)]
    fn compile_type_statement(&mut self, type_statement: &TypeStatement) -> CompileResult<()> {
        todo!()
    }

    /// Compile an expression statement.
    fn compile_expression(&mut self, expression: &Expression) -> CompileResult<()> {
        match expression {
            Expression::BlockExpression(BlockExpression { statements, .. }) => {
                self.code.push_instruction(&Instruction::Block(Block(
                    Compiler::new(Program::new(statements.clone())).compile_program()?.instructions,
                )));

                Ok(())
            }

            Expression::Identifier(Identifier { value, .. }) => {
                self.code.push_instruction(&Instruction::LoadName(value.clone()));

                Ok(())
            }

            Expression::NumberLiteral(NumberLiteral { value, .. }) => {
                self.code
                    .push_instruction(&Instruction::LoadConst(Value::LiteralValue(LiteralValue::Number(*value))));

                Ok(())
            }

            Expression::StringLiteral(StringLiteral { value, .. }) => {
                self.code
                    .push_instruction(&Instruction::LoadConst(Value::LiteralValue(LiteralValue::String(value.clone()))));

                Ok(())
            }

            Expression::BooleanLiteral(BooleanLiteral { value, .. }) => {
                self.code
                    .push_instruction(&Instruction::LoadConst(Value::LiteralValue(LiteralValue::Boolean(*value))));

                Ok(())
            }

            Expression::ArrayLiteral(ArrayLiteral { elements, .. }) => {
                fn literal_value(expression: Expression) -> Value {
                    match expression {
                        Expression::NumberLiteral(NumberLiteral { value, .. }) => Value::LiteralValue(LiteralValue::Number(value)),
                        Expression::BooleanLiteral(BooleanLiteral { value, .. }) => Value::LiteralValue(LiteralValue::Boolean(value)),
                        Expression::StringLiteral(StringLiteral { value, .. }) => Value::LiteralValue(LiteralValue::String(value)),
                        Expression::ArrayLiteral(ArrayLiteral { elements, .. }) => {
                            Value::LiteralValue(LiteralValue::Array(elements.into_iter().map(literal_value).collect()))
                        }
                        _ => panic!(),
                    }
                }

                self.code
                    .push_instruction(&Instruction::LoadConst(Value::LiteralValue(LiteralValue::Array(
                        elements.iter().map(|e| literal_value(e.clone())).collect(),
                    ))));
                Ok(())
            }

            Expression::FunctionLiteral(FunctionLiteral { .. }) => {
                todo!()
            }

            Expression::ObjectLiteral(ObjectLiteral { .. }) => {
                todo!()
            }

            Expression::PrefixExpression(PrefixExpression { operator, right, .. }) => {
                self.compile_expression(right)?;

                match operator {
                    Tokens::Minus => self.code.push_instruction(&Instruction::UnaryOp(UnaryOp::Minus)),
                    Tokens::Bang => self.code.push_instruction(&Instruction::UnaryOp(UnaryOp::Not)),
                    _ => panic!("Unknown operator: {}", operator),
                }

                Ok(())
            }

            Expression::InfixExpression(InfixExpression { left, operator, right, .. }) => {
                self.compile_expression(left)?;
                self.compile_expression(right)?;

                match operator {
                    Tokens::Plus => self.code.push_instruction(&Instruction::BinaryOp(BinaryOp::Add)),
                    Tokens::Minus => self.code.push_instruction(&Instruction::BinaryOp(BinaryOp::Sub)),
                    Tokens::Asterisk => self.code.push_instruction(&Instruction::BinaryOp(BinaryOp::Mul)),
                    Tokens::Slash => self.code.push_instruction(&Instruction::BinaryOp(BinaryOp::Div)),
                    Tokens::Percent => self.code.push_instruction(&Instruction::BinaryOp(BinaryOp::Mod)),
                    Tokens::EQ => self.code.push_instruction(&Instruction::BinaryOpEq(BinaryOpEq::Eq)),
                    Tokens::NEQ => self.code.push_instruction(&Instruction::BinaryOpEq(BinaryOpEq::Neq)),
                    Tokens::LT => self.code.push_instruction(&Instruction::BinaryOpEq(BinaryOpEq::Lt)),
                    Tokens::GT => self.code.push_instruction(&Instruction::BinaryOpEq(BinaryOpEq::Gt)),
                    Tokens::LTE => self.code.push_instruction(&Instruction::BinaryOpEq(BinaryOpEq::Lte)),
                    Tokens::GTE => self.code.push_instruction(&Instruction::BinaryOpEq(BinaryOpEq::Gte)),
                    _ => panic!(),
                }

                Ok(())
            }

            Expression::CallExpression(CallExpression { function, arguments, .. }) => {
                for argument in arguments.clone() {
                    self.compile_expression(&argument)?;
                }

                match *function.clone() {
                    Expression::Identifier(Identifier { value, .. }) => match get_builtin(value.clone()) {
                        Some(_) => self.code.push_instruction(&Instruction::LoadGlobal(value)),
                        None => self.code.push_instruction(&Instruction::LoadName(value)),
                    },
                    _ => todo!(),
                }

                self.code.push_instruction(&Instruction::CallFunction(arguments.len()));

                Ok(())
            }

            Expression::IndexExpression(IndexExpression { .. }) => {
                todo!()
            }

            Expression::IfExpression(IfExpression {
                condition,
                consequence,
                alternative,
                ..
            }) => {
                self.compile_expression(condition)?;

                fn compile_block(block: BlockExpression) -> CompileResult<Block> {
                    Ok(Block(Compiler::new(Program::new(block.statements)).compile_program()?.instructions))
                }

                self.code.push_instruction(&Instruction::If(
                    compile_block(*consequence.clone())?,
                    alternative.clone().map(|expression| compile_block(*expression.clone())).transpose()?,
                ));

                Ok(())
            }
        }
    }
}
