#![allow(unused_variables)] // TODO: remove this

use crate::error::*;
use sntk_bytecode::{code::*, interpreter::*, stack::*};
use sntk_core::parser::ast::*;

#[derive(Debug, Clone)]
pub struct Code {
    pub instructions: Vec<Instruction>,
    pub constants: Vec<Value>,
    pub names: Vec<String>,
}

impl Code {
    fn new() -> Self {
        Self {
            instructions: Vec::new(),
            constants: Vec::new(),
            names: Vec::new(),
        }
    }
    fn push_instruction(&mut self, instruction: Instruction) {
        self.instructions.push(instruction);
    }

    fn push_constant(&mut self, constant: Value) {
        self.constants.push(constant);
    }

    fn push_name(&mut self, name: String) {
        self.names.push(name);
    }

    fn push(&mut self, code: Code) {
        self.instructions.extend(code.instructions);
        self.constants.extend(code.constants);
        self.names.extend(code.names);
    }
}

/// Compile the AST generated by `sntk_core` parser into bytecode.
#[derive(Debug)]
pub struct Compiler {
    pub program: Program,
    pub code: Code,
}

pub type CompileResult<T> = Result<T, CompileError>;

/// Provides the basic methods of the compiler.
pub trait CompilerTrait {
    fn new(program: Program) -> Self;
    fn compile_program(&mut self) -> CompileResult<Interpreter>;
    fn compile_let_statement(&mut self, let_statement: LetStatement) -> CompileResult<()>;
    fn compile_return_statement(&mut self, return_statement: ReturnStatement) -> CompileResult<()>;
    fn compile_type_statement(&mut self, type_statement: TypeStatement) -> CompileResult<()>;
    fn compile_expression(&mut self, expression: Expression) -> CompileResult<()>;
}

impl CompilerTrait for Compiler {
    /// **Creates a new Compiler instance.**
    /// it takes an argument of type `Program`.
    fn new(program: Program) -> Self {
        Self { program, code: Code::new() }
    }

    /// Compile the AST generated by `sntk_core` parser into bytecode.
    fn compile_program(&mut self) -> CompileResult<Interpreter> {
        if self.program.errors.len() > 0 {
            return Err(CompileError::ParseError(self.program.errors.clone()));
        }

        for statement in self.program.statements.clone() {
            match statement {
                Statement::LetStatement(statement) => self.compile_let_statement(statement)?,
                Statement::ReturnStatement(statement) => self.compile_return_statement(statement)?,
                Statement::TypeStatement(statement) => self.compile_type_statement(statement)?,
                Statement::ExpressionStatement(ExpressionStatement { expression, .. }) => self.compile_expression(expression)?,
            };
        }

        macro_rules! iter {
            ($f:ident) => {
                self.code.$f.iter().map(|x| x.clone()).collect()
            };
        }

        Ok(Interpreter {
            instructions: iter! { instructions },
            constants: iter! { constants },
            names: iter! { names },
            ..Default::default()
        })
    }

    /// Compile a `let` statement.
    ///
    /// `let x: number = 5;` to bytecode:
    /// ```
    /// Instruction:
    ///     0: LoadConst 0
    ///     1: StoreName 0
    /// Constant:
    ///     0: 5
    /// Name:
    ///     0: x
    /// ```
    fn compile_let_statement(&mut self, let_statement: LetStatement) -> CompileResult<()> {
        let LetStatement { name, value, data_type, .. } = let_statement;

        self.code.push_name(name.clone().value);
        self.compile_expression(value)?;
        self.code.push_instruction(Instruction::StoreName(self.code.names.len() - 1));

        Ok(())
    }

    /// Compile a `return` statement.
    fn compile_return_statement(&mut self, return_statement: ReturnStatement) -> CompileResult<()> {
        todo!()
    }

    /// Compile a `type` statement.
    fn compile_type_statement(&mut self, type_statement: TypeStatement) -> CompileResult<()> {
        todo!()
    }

    /// Compile an expression statement.
    fn compile_expression(&mut self, expression: Expression) -> CompileResult<()> {
        match expression {
            Expression::NumberLiteral(NumberLiteral { value, .. }) => {
                self.code.push_instruction(Instruction::LoadConst(self.code.constants.len()));
                self.code.push_constant(Value::LiteralValue(LiteralValue::Number(value)));
                Ok(())
            }
            _ => unimplemented!(),
        }
    }
}
